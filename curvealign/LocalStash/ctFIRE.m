function object = ctFIRE(imgName,fireDir);
%get the output of the Fire process and convert to something that can be used by CurveAlign

%inputs:    imgName = name of the image we would like to get the fire output for
%           fireDir = directory where the fire output is located (string)
%
%outputs:   object = structure containing information about each fiber segment position and angle in image

%Copyright 2013, Jeremy Bredfeldt, LOCI, Morgridge Institute for Research

%number of nucleation points to skip between segment endpoints
lag = 1;

%load the fiber list from the fire output mat file (this is generated by the CT-Fire program
dirList = dir(fireDir);
for i = 1:length(dirList)
    if ~isempty(regexp(dirList(i).name,imgName,'once'))
        fibListStruct = load([fireDir dirList(i).name]);
        break;
    end
end

fibStruct = fibListStruct.data; %extract the fiber list structure
%check if struct is empty, if so, return an empty object
if isempty(fibStruct)
    object = [];
    return;
end

%loop through all fibers, get the center and angle of each point in each fiber
num_fib = length(fibStruct.Fai);
X = fibStruct.Xai;

%search first to find the number of segments
totSeg = 0;
for i = 1:num_fib
    fv = fibStruct.Fai(i).v;
    numSeg = length(fv)-lag;
    if numSeg > 0
        totSeg = totSeg + numSeg;
    end
end
        
%make an object of the right length
object(totSeg) = struct('center',[],'angle',[]);
segNum = 0;
for i = 1:num_fib
    fv = fibStruct.Fai(i).v;
    numSeg = length(fv)-lag;
    if numSeg > 0
        for j = 1:numSeg
            segNum = segNum + 1;
            v1 = fv(j);
            v2 = fv(j+lag);
            x1 = X(v1,:);
            x2 = X(v2,:);

            pt1 = [x1(2) x1(1)];
            pt2 = [x2(2) x2(1)];
            seg = [pt1; pt2];
            %get the center of the segment
            object(segNum).center = round(mean(seg));
            run = pt1(2) - pt2(2);
            rise = pt1(1) - pt2(1);
            theta = atan(-rise/run); %range -pi/2 to pi/2, neg is to make angle match boundary file
            thetaDeg = theta*180/pi;
            if thetaDeg < 0
                thetaDeg = thetaDeg + 180;
            end
            object(segNum).angle = thetaDeg;
        end
    end
end

end